1
00:00:01,000 --> 00:00:01,860
Welcome

2
00:00:04,966 --> 00:00:07,914
For this coding challenge, we are given two strings.

3
00:00:08,000 --> 00:00:09,292
-a main string-

4
00:00:10,000 --> 00:00:11,556
-and a target string.

5
00:00:12,000 --> 00:00:14,826
Our goal is to find the smallest section of the main

6
00:00:14,926 --> 00:00:18,260
string that contains all the characters in the target string.

7
00:00:21,866 --> 00:00:24,082
To do this, we will code a sliding window

8
00:00:24,182 --> 00:00:27,584
that dynamically adjusts its boundaries, while using a hashmap

9
00:00:27,684 --> 00:00:30,238
to keep track of the elements within the window

10
00:00:31,333 --> 00:00:35,409
We start by setting a left pointer that tracks the start of our window

11
00:00:35,516 --> 00:00:38,032
And a right pointer that tracks the end

12
00:00:39,133 --> 00:00:41,921
For any window to be viable as a sub-string, it

13
00:00:42,021 --> 00:00:45,177
must contain all the characters of the target string.

14
00:00:45,266 --> 00:00:47,353
So, we create a hashmap to store the

15
00:00:47,453 --> 00:00:50,086
counts of the characters in our target string

16
00:00:52,200 --> 00:00:56,180
And a hashmap to store the counts of the characters in our window

17
00:00:57,283 --> 00:00:59,507
We start by expanding our window to the

18
00:00:59,607 --> 00:01:02,487
right until it contains all the target characters.

19
00:01:21,083 --> 00:01:24,502
Once our window contains all the target characters, it

20
00:01:24,602 --> 00:01:28,021
becomes a viable substring. So, we stop expanding, and

21
00:01:28,121 --> 00:01:31,279
record it as the minimum sub-string we have found.

22
00:01:34,366 --> 00:01:37,670
Then, to see whether we can make it any smaller, we begin

23
00:01:37,770 --> 00:01:41,730
to shorten the window from the left, removing characters one by one.

24
00:01:44,816 --> 00:01:48,045
After each contraction, we check to see if the window is

25
00:01:48,145 --> 00:01:51,196
still viable, and if it's the smallest window so far.

26
00:01:59,283 --> 00:02:03,147
Once our window no longer contains all the target letters, it is

27
00:02:03,247 --> 00:02:07,296
no longer viable, and we stop contracting. Then, we begin to expand

28
00:02:07,396 --> 00:02:10,703
again towards the right to find the next viable window.

29
00:02:16,800 --> 00:02:20,757
Once the window becomes viable again, we stop expanding. We check

30
00:02:20,857 --> 00:02:24,316
the string to see if it's smaller than the minimum. Then,

31
00:02:24,416 --> 00:02:27,500
we begin to shorten the window from the left again.

32
00:02:28,583 --> 00:02:31,103
Once again, at every round, we check to see

33
00:02:31,203 --> 00:02:34,027
whether our window is the smallest found so far.

34
00:02:39,116 --> 00:02:40,984
And record it if it is.

35
00:02:56,083 --> 00:02:58,988
And once our window is again no longer viable, we

36
00:02:59,088 --> 00:03:02,055
stop contracting and expand to the right once more

37
00:03:06,150 --> 00:03:08,334
Finally, we reach the end of the

38
00:03:08,434 --> 00:03:11,546
string. Since our final window is non-viable-

39
00:03:13,633 --> 00:03:17,757
-we return the value of our smallest substring and end the program.

40
00:03:19,850 --> 00:03:21,626
If you'd like to see how these

41
00:03:21,726 --> 00:03:24,190
steps are coded, please continue to watch

